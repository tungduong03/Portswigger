# Exploiting cache implementation flaws

Trong các bài thực hành trước, bạn đã học cách khai thác lỗ hổng đầu độc bộ nhớ đệm web bằng cách thao túng các dữ liệu đầu vào không có khóa thông thường, chẳng hạn như tiêu đề HTTP và cookie. Mặc dù cách tiếp cận này có hiệu quả, nhưng nó chỉ mới đề cập đến bề nổi của những gì có thể xảy ra với việc đầu độc bộ nhớ đệm web.

Trong phần này, chúng tôi sẽ trình bày cách bạn có thể tiếp cận bề mặt tấn công lớn hơn nhiều để đầu độc bộ đệm web bằng cách khai thác những điểm kỳ quặc trong các triển khai cụ thể của hệ thống bộ đệm. Đặc biệt, chúng ta sẽ xem xét lý do tại sao lỗi trong cách tạo khóa bộ nhớ đệm đôi khi có thể khiến các trang web dễ bị đầu độc bộ nhớ đệm thông qua các lỗ hổng riêng biệt vốn thường được coi là không thể khai thác. Chúng tôi cũng sẽ chỉ cho bạn cách sử dụng các kỹ thuật cổ điển hơn nữa để có khả năng đầu độc bộ nhớ đệm cấp ứng dụng, thường mang lại hậu quả tàn khốc.

Những kỹ thuật này lần đầu tiên được Giám đốc nghiên cứu của chúng tôi, James Kettle, ghi chép lại trong bài thuyết trình "Web Cache Entanglement: Novel Pathways to Poisoning" tại BlackHat USA 2020. Nếu bạn muốn biết cách anh ấy phát hiện và khai thác những lỗ hổng này ngoài thực tế, bạn có thể truy cập bản ghi âm bài thuyết trình này và báo cáo kèm theo từ trang nghiên cứu của chúng tôi.

# Cache key flaws

Nói chung, các trang web lấy hầu hết dữ liệu đầu vào từ đường dẫn URL và chuỗi truy vấn. Do đó, đây là bề mặt tấn công được sử dụng rộng rãi cho nhiều kỹ thuật hack khác nhau. Tuy nhiên, vì dòng yêu cầu thường là một phần của khóa bộ đệm nên các đầu vào này theo truyền thống không được coi là phù hợp để đầu độc bộ đệm. Bất kỳ dữ liệu nào được đưa vào thông qua các đầu vào có khóa sẽ hoạt động như một trình phá bộ đệm, nghĩa là mục bộ đệm bị nhiễm độc của bạn gần như chắc chắn sẽ không bao giờ được cung cấp cho bất kỳ người dùng nào khác.

Tuy nhiên, khi xem xét kỹ hơn, hành vi của từng hệ thống lưu trữ đệm riêng lẻ không phải lúc nào cũng như bạn mong đợi. Trên thực tế, nhiều trang web và CDN thực hiện nhiều chuyển đổi khác nhau trên các thành phần có khóa khi chúng được lưu trong khóa bộ nhớ đệm. Điều này có thể bao gồm:

- Loại trừ chuỗi truy vấn
- Lọc ra các tham số truy vấn cụ thể
- Chuẩn hóa đầu vào trong các thành phần có khóa

Những chuyển đổi này có thể gây ra một số điều kỳ quặc không mong muốn. Những điều này chủ yếu dựa trên sự khác biệt giữa dữ liệu được ghi vào khóa bộ nhớ đệm và dữ liệu được truyền vào mã ứng dụng, mặc dù tất cả đều bắt nguồn từ cùng một đầu vào. Những lỗ hổng khóa bộ nhớ đệm này có thể bị khai thác để đầu độc bộ nhớ đệm thông qua các dữ liệu đầu vào ban đầu có vẻ không sử dụng được.

Trong trường hợp bộ nhớ đệm cấp ứng dụng được tích hợp đầy đủ, những điểm kỳ quặc này thậm chí có thể còn nghiêm trọng hơn. Trên thực tế, bộ nhớ đệm nội bộ có thể khó đoán đến mức đôi khi rất khó để kiểm tra chúng mà không vô tình làm hỏng bộ nhớ đệm đối với người dùng trực tiếp.

# Cache probing methodology (Thăm dò cache)

Phương pháp thăm dò lỗi triển khai bộ nhớ đệm có đôi chút khác biệt so với phương pháp đầu độc bộ nhớ đệm web cổ điển. Các kỹ thuật mới hơn này dựa vào các lỗi trong việc triển khai và cấu hình cụ thể của bộ nhớ đệm, có thể thay đổi đáng kể tùy theo từng trang web. Điều này có nghĩa là bạn cần hiểu sâu hơn về bộ nhớ đệm mục tiêu và hành vi của nó.

Trong phần này, chúng tôi sẽ phác thảo phương pháp cấp cao để thăm dò bộ nhớ đệm nhằm hiểu hành vi của nó và xác định mọi lỗi tiềm ẩn. Sau đó, chúng tôi sẽ cung cấp một số ví dụ cụ thể hơn về các lỗ hổng khóa bộ nhớ đệm phổ biến và cách bạn có thể khai thác chúng.

Phương pháp này bao gồm các bước sau:
- Xác định một bộ nhớ đệm oracle phù hợp
- Xử lý chìa khóa thăm dò
- Xác định một gadget có thể khai thác

## Identify a suitable cache oracle

Bước đầu tiên là xác định "cache oracle" phù hợp mà bạn có thể sử dụng để thử nghiệm. Cache oracle chỉ đơn giản là một trang hoặc điểm cuối cung cấp phản hồi về hành vi của bộ nhớ đệm. Điều này cần phải được lưu trong bộ nhớ đệm và phải chỉ ra theo một cách nào đó liệu bạn đã nhận được phản hồi được lưu trong bộ nhớ đệm hay phản hồi trực tiếp từ máy chủ. Phản hồi này có thể có nhiều dạng khác nhau, chẳng hạn như:

- Tiêu đề HTTP cho bạn biết rõ ràng liệu bạn có bị truy cập bộ nhớ đệm hay không
- Những thay đổi có thể quan sát được đối với nội dung động
- Thời gian phản hồi khác biệt

Trong điều kiện lý tưởng, bộ nhớ đệm cũng sẽ phản ánh toàn bộ URL và ít nhất một tham số truy vấn trong phản hồi. Điều này sẽ giúp dễ dàng nhận thấy sự khác biệt khi phân tích cú pháp giữa bộ nhớ đệm và ứng dụng, điều này sẽ hữu ích cho việc xây dựng các khai thác khác nhau sau này.

Nếu bạn có thể xác định rằng một bộ nhớ đệm của bên thứ ba cụ thể đang được sử dụng, bạn cũng có thể tham khảo tài liệu tương ứng. Tài liệu này có thể chứa thông tin về cách xây dựng khóa bộ nhớ đệm mặc định. Bạn thậm chí có thể tình cờ tìm thấy một số mẹo và thủ thuật hữu ích, chẳng hạn như các tính năng cho phép bạn xem trực tiếp khóa bộ nhớ đệm. Ví dụ, các trang web dựa trên Akamai có thể hỗ trợ tiêu đề Pragma: akamai-x-get-cache-key, mà bạn có thể sử dụng để hiển thị khóa bộ nhớ đệm trong tiêu đề phản hồi:

```http
GET /?param=1 HTTP/1.1
Host: innocent-website.com
Pragma: akamai-x-get-cache-key

HTTP/1.1 200 OK
X-Cache-Key: innocent-website.com/?param=1
```

## Probe key handling

Bước tiếp theo là điều tra xem bộ nhớ đệm có thực hiện bất kỳ xử lý bổ sung nào cho dữ liệu đầu vào của bạn khi tạo khóa bộ nhớ đệm hay không. Bạn đang tìm kiếm một bề mặt tấn công bổ sung ẩn bên trong các thành phần có vẻ như được khóa.

























